# 디자인 패턴 질문 & 답변 정리

## 패턴 구현 방식 비교

### 1. 객체 어댑터 패턴과 클래스 어댑터 패턴의 차이점 및 사용 시점

| 구분      | 객체 어댑터 패턴                                          | 클래스 어댑터 패턴                           |
| --------- | --------------------------------------------------------- | -------------------------------------------- |
| 구현 방식 | 기존 객체 포함 (Composition)                              | 기존 클래스 상속 (Inheritance)               |
| 장점      | 다중 상속 불가 언어(Java 등)에서도 사용 가능, 유연성 높음 | 기존 클래스 동작 직접 재정의 가능, 코드 간결 |
| 단점      | 위임 코드 필요, Adaptee protected 멤버 접근 불가          | 다중 상속 필요 시 제약, 유연성 낮음          |
| 사용 시점 | 대부분의 경우 사용 (유연성)                               | 상속 통한 직접 수정 필요 시 사용             |

- **실무 사용:** 객체 어댑터가 대부분 선호됨.
- **특수 상황:** 성능 최적화나 단순 프로젝트 시 클래스 어댑터 사용 가능.

---

### 2. 템플릿 메소드 패턴을 abstract 클래스 대신 interface로 구현 가능 여부

- Java 8 이후 가능 (`default` 메서드 사용).
- 제한 사항:
  - 상태(state) 관리 불가
  - `final`로 메서드 선언 불가
  - `protected` 접근 불가
- 권장: 공통 상태와 흐름 관리가 필요한 경우 abstract 클래스 사용
- 간단한 알고리즘 틀: interface + default method 가능

### 3. 전략 패턴에서 전략 객체를 매번 생성하는 것과, 재사용하는 것의 차이점

#### 1. 매번 새로 생성할 때

- **장점**

  - 상태가 완전히 분리되어 안전함 (서로 다른 Context 간 간섭 X)
  - 전략 객체마다 다른 설정을 적용하기 용이
  - 동시성 문제 발생 가능성이 낮음

- **단점**
  - 객체 생성 비용이 반복적으로 발생
  - GC 부하 증가 가능성
  - 동일한 전략을 중복 생성하게 되어 비효율적일 수 있음

#### 2. 전략 객체를 재사용할 때

- **장점**

  - 객체 생성 비용 절감 (성능 향상)
  - 메모리 사용량 감소
  - 동일한 정책 유지 가능 (일관성 향상)

- **단점**
  - 내부 상태가 있는 전략의 경우, Context 간 상태 간섭 위험
  - 일부 Context만 전략을 변경하기 어려움
  - 멀티스레드 환경에서 동기화 필요

---

## 발생 가능한 문제

### 1. 옵저버 패턴에서 Observer를 제거하지 않으면 메모리 누수가 발생하는 이유

- **관찰 대상(Subject)** 은 내부에 **Observer 리스트(참조 컬렉션)** 를 가지고 있음  
  → 즉, `Subject` 객체가 `Observer` 인스턴스를 계속 **참조**하는 구조

- **문제 발생 시점**

  - `Observer` 객체가 더 이상 필요 없어서 GC 대상이 되어야 하지만,
  - `Subject` 가 그 Observer를 리스트에서 제거하지 않으면 여전히 참조 중이므로  
    **Garbage Collector가 수거하지 못함**
  - 결과적으로, `Observer` 객체가 메모리에 남아 **메모리 누수(Memory Leak)** 발생

- **예시 상황**

  - GUI 이벤트 리스너, 실시간 알림 시스템 등에서  
    해제되지 않은 구독(Subscription)이 계속 누적되는 경우

- **예방 방법**
  - `Subject` 가 더 이상 필요 없는 Observer를 명시적으로 `removeObserver()` 로 제거
  - 약한 참조(WeakReference) 사용하여 GC에 의해 자동 해제되도록 설계
  - 옵저버 생명주기와 Subject 생명주기를 명확히 분리 및 관리

### 2. 옵저버 패턴에서 1:N 관계가 많아질 때 성능이나 복잡성을 관리하는 방법

- **1:N 관계의 문제점**

  - Subject 하나가 너무 많은 Observer를 관리하게 되면
    - 모든 Observer에게 알림을 순차적으로 보내는 데 **시간 지연 발생**
    - Observer 등록/제거 관리 로직이 복잡해짐
    - 예외 발생 시 특정 Observer 때문에 전체 알림 흐름이 끊길 수 있음

- **관리 및 최적화 방법**

  1. **비동기(Asynchronous) 통지 방식 적용**

     - 알림을 즉시 실행하지 않고, 큐(queue)나 이벤트 루프를 통해 비동기 처리  
       → Subject는 빠르게 반환하고, Observer는 백그라운드에서 업데이트 처리  
       → 예: `ExecutorService`, `CompletableFuture` 사용

  2. **배치 처리(Batch Notification)**

     - 일정 주기마다 여러 이벤트를 모아 한 번에 통지  
       → 잦은 이벤트 발생 시 불필요한 중복 호출 감소

  3. **필터링 및 조건부 구독**

     - Observer마다 필요한 이벤트만 받도록 필터 등록  
       → 전체 BroadCast를 줄이고 효율적 이벤트 전달 가능

  4. **이벤트 버스(Event Bus) 또는 메시징 시스템 활용**

     - 직접 Observer 리스트를 관리하지 않고, Event Bus 또는 Message Broker (예: Kafka, Guava EventBus, RxJava) 이용  
       → Subject와 Observer 간 결합도 완화 및 성능 향상

  5. **Priority Queue 또는 그룹화**
     - 중요도나 카테고리별로 Observer를 분류해 우선순위 통지  
       → 예: "UI 관련 알림 → 로그 기록 → 통계 처리" 순서로 통지

---

## 유사 패턴 간 차이점

### 1. 템플릿 메서드 패턴 vs 전략(Strategy) 패턴

| 구분      | 템플릿 메서드 패턴                   | 전략 패턴                                   |
| --------- | ------------------------------------ | ------------------------------------------- |
| 구현 방식 | 상속(Inheritance)                    | 구성(Composition)                           |
| 변경 시점 | 컴파일 타임                          | 런타임                                      |
| 제어      | 부모 클래스                          | 클라이언트                                  |
| 결합도    | 강결합                               | 약결합                                      |
| 장점      | 코드 재사용 높음, 알고리즘 구조 강제 | 런타임 유연성, 재사용성 높음                |
| 단점      | 단일 상속 제한, 결합도 높음          | 클래스 수 증가, 클라이언트가 전략 알아야 함 |

---

### 2. 어댑터 패턴 vs Facade 패턴

| 구분 | 어댑터(Adapter)                            | 퍼사드(Facade)                    |
| ---- | ------------------------------------------ | --------------------------------- |
| 목적 | 인터페이스 변환, 호환성 제공               | 복잡한 시스템 단순화              |
| 초점 | 기존 클래스 호환                           | 여러 서브시스템 감춤              |
| 구조 | Target 인터페이스 맞춤                     | 여러 객체를 하나로 묶음           |
| 장점 | 기존 코드 수정 없이 새로운 인터페이스 적용 | 시스템 단순화, 유지보수 용이      |
| 단점 | 변환 계층 추가로 복잡도 증가               | Facade가 커지면 또 다른 복잡 구조 |

- **함께 쓰는 경우:**  
  외부 라이브러리 단순화(Facade) + 인터페이스 변환(Adapter)

---

### 3. 팩토리 메소드 패턴 vs 추상 팩토리 패턴

| 구분      | 팩토리 메소드                   | 추상 팩토리                                      |
| --------- | ------------------------------- | ------------------------------------------------ |
| 목적      | 객체 생성 책임 서브클래스 위임  | 관련 객체 묶음(제품군) 생성                      |
| 생성 대상 | 하나의 제품                     | 여러 제품군                                      |
| 확장 방식 | 새 제품 추가 시 서브클래스 생성 | 제품군 전체를 새로운 팩토리로 교체               |
| 구조      | 상속 기반                       | 조합 기반                                        |
| 예시      | `ShapeFactory.createShape()`    | `GUIFactory.createButton()`, `createTextField()` |

---

## 패턴과 SOLID 원칙

### 1. 템플릿 메소드와 LSP 위반 가능성

**문제:** 서브클래스가 상위 클래스의 알고리즘 전제조건(전처리, 순서, 반환값 등)을 깨뜨리는 경우

```java
abstract class Bird {
    public final void move() {
        takeOff();
        fly(); // 모든 새가 날 수 있다고 가정 → Penguin에서는 X
        land();
    }
    protected abstract void fly();
}

class Penguin extends Bird {
    protected void fly() {
        throw new UnsupportedOperationException(); // X. LSP 위반
    }
}
```

## 해결 방안

- 상속 계층 재설계 (`FlyingBird` 분리)
- 훅(Hook) 메소드 사용
- 전략 패턴(Strategy)으로 상속 대신 합성 사용
- `final` + `protected`로 오버라이드 범위 제한

### 2. SOLID 원칙들이 서로 충돌할 때 해결 방법

- **충돌 예시**

  - SRP(단일 책임 원칙)와 OCP(개방-폐쇄 원칙)는 자주 충돌  
    → SRP를 철저히 지키면 클래스가 세분화되어 구조가 복잡해짐  
    → 반면 OCP를 강조하면 추상화와 확장이 늘어나 복잡도 증가
  - LSP(리스코프 치환 원칙)과 ISP(인터페이스 분리 원칙)도 충돌할 수 있음  
    → 인터페이스를 세분화하면 치환 가능성이 줄어듦

- **해결 방향**
  1. **우선순위를 상황에 따라 조정**  
     → 확장성과 변경 빈도 중 어떤 게 더 중요한지 결정  
     → “변경이 자주 일어나는 부분”을 기준으로 원칙 선택
  2. **과도한 추상화 지양**  
     → 실제 유지보수성이 떨어지면 원칙을 완화  
     → 모든 원칙은 절대규칙이 아니라 **트레이드오프의 기준**
  3. **테스트 주도 설계(TDD)로 검증**  
     → 실제 변경 케이스에 맞는 구조인지 테스트로 판단
  4. **도메인 중심 설계(DDD) 접근**  
     → 기술적 원칙보다 도메인 모델의 명확성을 우선시

### 3. SOLID의 SRP에서 "하나의 책임(이유)"을 판단하는 방법

- **SRP(단일 책임 원칙)**: 클래스는 오직 **하나의 변경 이유**만 가져야 한다.

- **판단 기준**
  1. **변경 이유의 주체(Actor)를 구분**
     - 서로 다른 이해관계자가 요구사항을 바꾼다면, 책임이 다르다는 신호  
       → 예: 회계팀, 인사팀, 보안팀 등 서로 다른 조직의 요청이라면 분리 필요
  2. **관심사(Concern) 단위로 구분**
     - 데이터 저장, 비즈니스 로직, UI 표시 등 서로 다른 기능 축을 분리
  3. **변경의 방향성으로 판단**
     - 한 이유의 변경이 다른 기능에 영향을 주면 SRP 위반
  4. **클래스의 이름으로 테스트**
     - 클래스 이름이 “그리고(And)”를 포함하면 보통 두 가지 이상의 책임이 있음  
       → 예: `UserServiceAndLogger` ❌

### 4. SRP나 OCP를 위반하면 실제 코드 유지보수에서 발생할 수 있는 문제점

- **SRP 위반 시**

  - 한 부분의 변경이 다른 기능에 영향 → **결합도 상승**
  - 여러 개발자가 동시에 수정 시 충돌 증가
  - 테스트가 복잡해지고 단위 테스트 불가능해짐
  - 클래스 크기 비대 → 코드 가독성 저하

- **OCP 위반 시**
  - 새로운 기능 추가 시 기존 코드 수정 필요
  - 수정으로 인한 **회귀 버그(Regression Bug)** 발생 가능
  - 유연성 저하 → 변경 비용 증가
  - 인터페이스나 추상화가 없어서 **확장보다 수정이 기본 전략**이 됨

### 5. ISP를 적용하면 클래스 수가 늘어나는 단점을 해결하는 방법

- **문제 상황**

  - 인터페이스를 세분화하면 관리해야 할 인터페이스, 클래스 수가 많아짐  
    → 설계 복잡도와 코드량 증가

- **해결 방법**
  1. **팩토리나 퍼사드(Facade) 패턴 적용**
     - 여러 작은 인터페이스를 묶어서 제공하는 중간 계층 도입  
       → 클라이언트 입장에서 단순화
  2. **조합(Composition)을 활용한 집합 인터페이스**
     - 다수의 작은 인터페이스를 조합하여 사용하는 구조  
       → 필요한 기능만 조립 가능
  3. **인터페이스 디폴트 메서드 활용 (Java 8 이상)**
     - 공통 동작을 디폴트 메서드로 구현해 중복 코드 줄이기
  4. **자동 의존성 주입(DI) 컨테이너 활용**
     - 스프링처럼 다수 인터페이스의 구현체를 자동 관리하도록 설정

### 6. 의존성 주입(DI)이란?

- **정의**

  - 객체가 직접 의존 객체를 생성하지 않고, 외부에서 주입받는 설계 원칙
  - 즉, 클래스 내부에서 `new` 키워드로 의존 대상을 만들지 않고  
    **생성자, 세터, 인터페이스** 등을 통해 외부에서 전달받음

- **예시**

  ```java
  // ❌ Bad: 직접 의존성 생성
  public class OrderService {
      private final OrderRepository repo = new OrderRepository();
  }

  // ✅ Good: 외부에서 주입
  public class OrderService {
      private final OrderRepository repo;
      public OrderService(OrderRepository repo) {
          this.repo = repo;
      }
  }
  ```

#### DI의 목적

1. **결합도 감소 (Loose Coupling)**

   - 객체가 **구체 클래스**가 아닌 **인터페이스**에 의존함으로써 코드 변경에 유연하게 대응 가능
   - 구현체 교체 시에도 클라이언트 코드 수정이 최소화됨

2. **테스트 용이성 (Testability)**

   - 외부에서 **Mock 객체**를 주입할 수 있어 단위 테스트가 쉬워짐
   - 실제 의존 객체를 생성하지 않아도 테스트 환경 구성 가능

3. **유연성 향상 (Flexibility)**

   - 런타임 시점에 의존 객체를 교체하거나 확장 가능
   - 설정 파일이나 컨테이너 설정만 수정해도 다른 구현체로 교체 가능

4. **객체 생명주기 관리 (Lifecycle Management)**
   - IoC 컨테이너(Spring 등)가 객체의 생성, 초기화, 소멸까지 관리
   - 개발자는 비즈니스 로직에만 집중할 수 있음

---

## 멀티스레드와 싱글톤

### 1. Holder Pattern vs Double-Checked Locking(DCL)

| 구분   | DCL                                         | Holder Pattern                                |
| ------ | ------------------------------------------- | --------------------------------------------- |
| 동작   | 인스턴스가 없을 때만 `synchronized`         | 내부 static 클래스 로딩 시점에 인스턴스 생성  |
| 문제점 | 명령어 재배치, 가시성 문제, `volatile` 필요 | JVM 클래스 로딩에서 thread-safe 자동 보장     |
| 안전성 | Java 5 이후 `volatile` 사용 시 안전         | 언어 차원에서 안전, 단순하고 오류 가능성 낮음 |
| 성능   | 첫 호출 시 lock 비용                        | 동기화 불필요, 게으른 초기화                  |

### 2. JVM의 static 처리

- 클래스 로딩 시점에 static 변수/블록 초기화
- Initialization 단계에서 static 변수 실제 값 할당, static 블록 실행
- JVM이 초기화를 직렬화하여 멀티스레드 안전 보장

### 3. Lazy Initialization + DCL 방식의 문제

- 명령어 재배치 가능 → 미완성 객체 노출
- 메모리 가시성 문제 → `volatile` 없으면 다른 스레드에서 캐시 참조
- 복잡성 → Holder Pattern 사용 권장

---

## 패턴 적용 범위 / 시나리오

### 1. 어댑터 패턴 활용 범위

**핵심:** 인터페이스 호환 문제 해결

**활용 사례:**

- 새 라이브러리/시스템 통합
- 서로 다른 모듈 호환성 조정
- 테스트/Mock 객체 작성
- 데이터 포맷 변환 (JSON ↔ XML)

**결론:**
기존 코드에 새 시스템을 붙이는 경우뿐 아니라, **인터페이스 불일치 모든 상황에서 사용 가능**

### 2. 리팩토링 기법

#### 리팩토링의 목적

- 외부 동작은 유지하면서 내부 구조를 개선하는 작업
- 코드 품질 향상 + 유지보수성 확보

#### 리팩토링 기법

**1. 메서드 추출 (Extract Method)**

- 길고 복잡한 메서드를 **의미 있는 작은 메서드로 나누는 기법**
- 예: 하나의 메서드에서 계산, 출력, 로깅을 하고 있다면, 각각을 별도의 메서드로 분리

**2. 메서드 인라인 (Inline Method)**

- 불필요하게 분리된 메서드를 **본문으로 합치는 기법**
- 메서드 호출만 있고 내부 코드가 단순할 때 사용

**3. 클래스 추출 (Extract Class)**

- 한 클래스가 **여러 책임**을 가지면 책임별로 새로운 클래스로 분리
- 예: `ReportManager`가 보고서 생성, 저장, 이메일 전송까지 한다면 각 기능별로 클래스 생성

**4. 클래스 인라인 (Inline Class)**

- 너무 작은 클래스는 상위 클래스나 다른 관련 클래스에 **합치는 기법**
- 불필요한 추상화 줄이기

**5. 조건문 단순화 (Decompose Conditional)**

- 복잡한 if-else를 **조건별로 별도 메서드로 분리**
- 코드 가독성과 유지보수성을 높임

**6. 다형성 적용 (Replace Conditional with Polymorphism)**

- 조건문으로 분기하던 로직을 **상속과 오버라이딩, 인터페이스**로 대체
- 새로운 케이스가 생겨도 기존 코드를 수정하지 않고 확장 가능

**7. 중복 코드 제거**

- 같은 코드가 여러 곳에 있다면 **메서드나 클래스로 통합**
- 공통 로직을 하나로 모아 유지보수성을 높임

**8. 이름 바꾸기 (Rename)**

- 메서드, 변수, 클래스 이름이 의미 없거나 혼동될 경우 **의미 있는 이름으로 변경**
- 읽는 사람이 바로 이해할 수 있게 함

**9. 데이터 구조 개선**

- 단순 값 대신 의미 있는 객체로 변환하거나, 필드 접근을 캡슐화
- 예: 원시값 대신 `Money` 클래스 사용, 컬렉션 접근을 getter/setter로 관리

**10. 가드 클라우즈 (Guard Clauses)**

- 깊은 if-else 대신 **예외나 종료 조건을 먼저 처리하고 메서드 종료**
- 코드 흐름을 단순하게 만들고 들여쓰기 줄임
