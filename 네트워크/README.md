# 네트워크 

## 키워드
**OSI 7계층**
- 네트워크 통신이 일어나는 과정을 7단계로 나눈 표준 모델.계층 간 역할을 분리하여 구조적 설계 및 문제 추적 용이.
1. **물리 계층 (Physical)**:
    - 데이터를 전기 신호나 광 신호를 통해 비트를 전송하는 계층
    - 리피터, 케이블, 허브
2. **데이터 링크 계층 (Data Link)**:
    - 물리 계층의 정보를 안전하게 전달, Mac 주소 통신, 에러 검출 및 흐름 제어
    - 브릿지, 스위치
3. **네트워크 계층 (Network)**:
    - 데이터를 목적지까지 안전하고 빠르게 전달, 라우팅, IP 주소 지정
    - 라우터, IP
4. **전송 계층 (Transport)**:
    - 포트를 열어 프로그램 간 전송 제공, 신뢰성/비신뢰성 통신
    - TCP, UDP
5. **세션 계층 (Session)**: 
    - 논리적 연결 담당, TCP/IP 세션 생성 및 제거
    - API, Socket
6. **표현 계층 (Presentation)**
    - 데이터 표현의 독립성 제공, 암호화, 인코딩, 압축
    - JPEG, MPEG
7. **응용 계층 (Application)**
    - 사용자 인터페이스, 응용 서비스 제공 (전자우편, 데이터베이스 관리 등)
    - HTTP, FTP, DNS

**3-way Handshake(연결 성립)** 
- TCP 연결 설정 절차. SYN → SYN+ACK → ACK 순서로 서로의 연결 준비를 확인.
- 단계:
    - **1단계**: 클라이언트 → 서버 SYN 패킷 전송
    - **2단계**: 서버 → 클라이언트 SYN/ACK 패킷 전송 (ACK: x+1)
    - **3단계**: 클라이언트 → 서버 ACK 패킷 전송 (ACK: y+1)

**4-way Handshake (연결 해제)**
- TCP 연결 해제 과정으로, FIN과 ACK 패킷이 네 번 교환되며 양방향 통신을 종료한다.
- 단계: 
    - **1단계**: 클라이언트 → 서버. FIN 플래그 전송 (연결 종료 요청)
    - **2단계**: 서버 → 클라이언트. ACK 전송, CLOSE_WAIT 상태 (남은 데이터 전송)
    - **3단계**: 서버 → 클라이언트. FIN 플래그 전송 (연결 종료 준비 완료)
    - **4단계**: 클라이언트 → 서버. ACK 전송, TIME_WAIT 후 연결 종료

**TIME_WAIT** 
- TCP 종료 후 일정 시간 대기 상태. 중복 패킷 방지 및 연결 완전 종료 보장.

**TCP (Transmission Control Protocol)**
- 신뢰성 있는 연결 지향형 프로토콜. 
- 데이터 재전송, 순서 제어, 흐름제어·혼잡제어 수행.
- 속도 낮음.

**TCP가 보장하는 Reliable Network의 4가지 문제**
- 손실 (Loss) : 패킷이 손실될 수 있음
- 순서 변경 (Reordering) : 패킷 순서가 바뀔 수 있음
- 혼잡 (Congestion)	: 네트워크가 혼잡해질 수 있음
- 과부하 (Overload)	: 수신자가 과부하 상태가 될 수 있음

**흐름 제어 (Flow Control)** : 
- 송신/수신측 속도 차이 해결 (End-to-End).
- **Stop and Wait** 
    - 매번 전송한 패킷의 확인 응답을 받아야 다음 패킷 전송
- **Sliding Window (Go Back N ARQ)** 
    - 혼잡 시 전송속도를 절반으로 줄이고 혼잡이 없으면 선형적으로 증가하는 방법. 
    - 수신측 윈도우 크기만큼 확인 응답 없이 전송 가능
    - 동적으로 흐름 제어. 
    - RWND(Receive Window) 사용

**혼잡 제어 (Congestion Control)**
- 송신/네트워크 처리 속도 차이 해결.
- 순서: Slow Start → AIMD → Fast Retransmit → Fast Recovery
- **Slow Start** 
    - 지수 함수적으로 증가(ACK마다 +1), 혼잡 발생 시 1로 감소. 이후 임계값까지 지수 증가, 그 후 선형 증가
    - 연결 초반 전송량을 지수적으로 증가시켜 네트워크 용량 파악.
- **AIMD (Additive Increase / Multiplicative Decrease)** 
    - 윈도우 크기를 1씩 증가, 실패 시 절반으로 감소. 공평하지만 초기 대역폭 활용이 느림
- **Fast Retransmit**
    - 중복 ACK 3개 수신 시 즉시 재전송, 타임아웃 대기 불필요
    - 중복된 ACK 감지 시, 손실 패킷을 즉시 재전송하여 효율 높임.
- **Fast Recovery**
    - 혼잡 발생 시 윈도우를 1이 아닌 절반으로 줄이고 선형 증가.

**RWND (Receive Window)**
- 수신 측 버퍼 여유 공간. 송신 측이 이 값을 보고 전송량 조절.

**CWND (Congestion Window)**
- 송신 측이 혼잡 상황에 따라 자체 조절하는 윈도우 크기.

**UDP**
- 비연결형, 신뢰성 없는 전송 프로토콜 (Transport Layer). 데이터를 데이터그램 단위로 처리.  - TCP보다 속도 ↑
- 오류는 Application Layer에서 처리 필요
- 헤더 구성	: Source Port, Destination Port, Length, Checksum. 단순 구조로 오버헤드 적음.
- ex, 	실시간 방송, 온라인 게임, DNS

**IP의 역할과 UDP**
- 	IP는 장치 간 통신만 담당하며, UDP는 포트 번호를 사용하여 한 장치 내 여러 프로그램 간 통신을 지원.

**UDP 오류 해결**
- 자체적인 신뢰성 기능 없음. 오류 발생 시 재전송/순서 보정은 애플리케이션이 처리 (헤더 체크섬 정도만 제공).

**DNS와 UDP 통신 이유**
- 작은 데이터 크기 : DNS Request가 UDP segment에 담길 정도로 작음
- 연결 유지 불필요 : 3-way handshake 오버헤드 불필요
- Application Layer 제어: Timeout, Resend 등으로 신뢰성 보완 가능
- 포트: DNS는 UDP 53번 포트 사용

**대칭키 암호화(Symmetric Key)**
- 암호화와 복호화에 같은 키 사용
- 장점: 속도가 매우 빠름
- 단점 : 키 전달 과정에서 해킹 위험
- 보안 요소 : Confidentiality
- 예: AES, DES.

**공개키 암호화**
- 암호화와 복호화에 다른 키 사용 (공개키 + 비밀키)
- 장점: 키 분배 문제 해결, 공개키는 공개 가능
- 단점: 암호화/복호화가 복잡하고 느림
- 보안 : Confidentiality (+ MAC/전자서명으로 Integrity, Authenticity 보완)
- 예: RSA.

**하이브리드 암호화**
- 공개키로 세션키(대칭키)를 안전하게 교환 → 이후 대칭키로 실제 데이터 암호화. (SSL/TLS 기반) HTTPS에서 사용.

**공개키**
- 대중에게 공개. 암호화/서명 검증에 사용.

**개인키** 
- 소유자만 소유. 복호화/서명 생성에 사용.

**디지털 인증서 (Digital Certificate)**
- 신뢰기관(CA)이 발급하는 서버 인증 정보. 공개키, 도메인, 서명 포함.

**CA (Certificate Authority)**
- 신뢰성이 검증된 기관으로, 서버의 신원 보증 및 공개키를 담은 인증서 발급 역할.

**SSL/TLS**
- HTTPS에서 사용되는 보안 프로토콜로, 인증·암호화·무결성을 제공

**HTTP(HyperText Transfer Protocol)**
- 웹에서 데이터를 주고받기 위한 비연결형·비상태형 통신 프로토콜
- 연결 유지 X, 데이터 암호화되지 않은 평문 전송 → 보안 취약.
- 포트 80

**HTTPS(HyperText Transfer Protocol Secure)**
- HTTP에 SSL/TLS를 적용한 보안 통신 프로토콜(하이브리드 암호화 방식 사용)
- 포트 443

**HTTPS 통신 흐름**
1. 서버(A)가 공개키와 개인키 생성
2. 신뢰할 수 있는 CA(Certificate Authority)와 계약, 공개키 관리 위임
3. CA가 서버 정보와 공개키를 담은 인증서를 CA의 개인키로 암호화하여 제공
4. 클라이언트가 HTTPS 요청 시, 서버는 암호화된 인증서 전송
5. 브라우저가 CA의 공개키(기본 내장)로 인증서 복호화하여 서버 공개키 획득
6. 클라이언트가 대칭키(pre-master-key) 생성 후 서버 공개키로 암호화하여 전송
7. 서버가 개인키로 대칭키 복호화
8. 	이후 클라이언트-서버 간 통신은 대칭키로 암호화/복호화

**TLS Handshake 과정**
1. ClientHello/ServerHello 
2. 인증서 교환 
3. 세션키 생성 
4. 암호화 통신 시작.

**SSL/TLS 계층 위치**
- OSI 표현 계층과 전송 계층 사이에서 작동.

**인증서**
- 서버의 신원을 증명하기 위한 파일
- HTTPS 연결 시 신뢰성을 확보

**세션**
- 클라이언트와 서버 간의 상태를 유지하기 위한 논리적 연결

**쿠키**
- 클라이언트 측에 저장되는 작은 데이터 조각. 세션 유지를 도움.

**포트 (Port)**
- 프로세스 식별자. HTTP(80), HTTPS(443), DNS(53), SSH(22) 등.

**체크섬 (Checksum)**
- 전송 데이터 오류 검출용 필드 (TCP/UDP 헤더 포함).

---
## 질문답

### OSI 7 계층
***1. 브라우저에서 GET /users 같은 REST API 호출 시, 데이터가 클라이언트에서 서버까지 가는 과정에서 OSI 계층별로 어떤 일이 일어날까?***
- ***응용 계층(7)***: HTTP 요청 메시지 생성 (GET /users HTTP/1.1)
  클라이언트 측 (송신): 데이터는 상위 계층에서 준비된 요청이 점점 낮은 계층으로 캡슐화(encapsulation) 되면서 실제 신호로 변환됨

    - 7계층 - 응용 계층: HTTP 요청 메시지 생성 (GET /users HTTP/1.1)
    - 6계층 - 표현 계층: 데이터 인코딩, HTTPS라면 SSL/TLS 암호화
    - 5계층 - 세션 계층: 세션 연결 관리, 세션 ID 생성
    - 4계층 - 전송 계층: TCP 세그먼트 생성, 포트 번호 추가 (출발지:랜덤, 목적지:80/443)
    - 3계층 - 네트워크 계층: IP 패킷 생성, IP 주소 추가, 라우팅 경로 결정
    - 2계층 - 데이터 링크 계층: 이더넷 프레임 생성, MAC 주소 추가
    - 1계층 - 물리 계층: 전기/광/무선 신호로 변환하여 전송

- ***네트워크 경로***: 중간 장치들은 패킷을 목적지까지 안전하게 전달하는 역할만 수행하고, 실제 데이터 내용은 변경하지 않음

    - 라우터: 3계층까지 처리, IP 헤더 확인 후 다음 홉으로 전달
    - 스위치: 2계층까지 처리, MAC 주소 기반으로 전달

- ***서버 측 (수신)***: 수신 측은 송신 계층에서 캡슐화된 데이터를 역순으로 해제(decapsulation) 하고 실제 요청 처리 수행
    - 1계층 - 물리 계층: 물리 신호를 디지털 데이터로 변환
    - 2계층 - 데이터 링크 계층: MAC 주소 확인, 프레임 검증
    - 3계층 - 네트워크 계층: IP 주소 확인, 패킷 검증
    - 4계층 - 전송 계층: 포트 확인, TCP 검증, 순서 재조립
    - 5계층 - 세션 계층: 세션 유효성 확인
    - 6계층 - 표현 계층: 복호화, 압축 해제
    - 7계층 - 응용 계층: HTTP 요청 파싱, 비즈니스 로직 처리


***2. 실무에서는 OSI 7계층보다 TCP/IP 4계층을 더 많이 쓰는 이유***
- OSI 7계층은 이론적 모델이고, TCP/IP 4계층은 실제 인터넷 프로토콜 기반
- TCP/IP가 더 단순하고 실용적
- 인터넷이 TCP/IP 기반으로 발전했기 때문에 실무에서는 TCP/IP 모델이 더 적합
- OSI의 5,6,7계층이 TCP/IP에서는 응용 계층으로 통합되어 있어 복잡도 감소
- 계층 단순화(TCP, IP, 애플리케이션) → 개발/디버깅 용이

### [TCP] 3 way handshake & 4 way handshake
***1. TCP에서 사용하는 network congestion avoidance algorithm은 뭔가?***
- ***Slow Start***: 초기에 CWND를 1 MSS부터 시작해 지수적으로 증가
- ***Congestion Avoidance***: 임계값(ssthresh) 도달 후 선형적으로 증가
- ***Fast Retransmit***: 3개의 중복 ACK 받으면 즉시 재전송
- ***Fast Recovery***: 패킷 손실 감지 시 CWND를 절반으로 줄이고 선형 증가 재개
- ***Tahoe, Reno, New Reno, CUBIC*** 등 다양한 알고리즘 존재

### TCP/IP (흐름제어/혼잡제어)
***1. TCP의 흐름 제어(RWND)와 혼잡 제어(CWND)는 각각 어떤 문제를 해결하며, 실제 전송 윈도우 계산 시 두 값은 어떻게 결합되는가?***
- ***RWND (Receiver Window)***
    - 수신 측 버퍼 크기에 따라 송신량 제한
    - 수신 측이 처리할 수 있는 만큼만 보내도록 조절 → 수신 과부하 방지
    - 동적으로 수신 가능 버퍼 크기를 ACK에 포함하여 - 송신 측에 알림

- ***CWND (Congestion Window)***
    - 네트워크 혼잡을 감지하고 전송량 조절
    - Slow Start, Congestion Avoidance, Fast Recovery 등을 통해 네트워크 혼잡 예방 및 효율적인 전송

- 실제 전송 윈도우 계산 시 윈도우 결정 방식
    - 수신 측 처리 가능량과 네트워크 상태 모두 고려해야 함
    - 송신 측이 한 번에 보낼 수 있는 데이터 크기는 min(RWND, CWND)

### 대칭키 & 공개키
***1. 공개키/비밀키로 계속 통신하지 않고 대칭키를 주고받아서 통신하는 이유***
- 공개키 암호는 느림 → 대칭키로 교환 후 데이터 통신 시 속도 개선
- 대칭키: 빠른 데이터 암호화
- 공개키: 초기 키 교환용 안전 통로

***2. 공개키 암호와 방식의 단점을 MAC(Message Authentication Code)나 전자 서명(Digital Signature)으로 해결한다는데 어떻게 해결하나?***
- **공개키 암호화 방식의 단점**
    - 연산 비용 높음
    - 암호화 속도 느림
    - 키 관리 부담

- **MAC**
    - 송수신자 공유 키를 기반으로 생성
    - 메시지 **위·변조 여부 확인 가능**
    - **무결성**을 보장하지만 부인 방지 기능은 없음

- **전자 서명**
    - 송신자가 비밀키로 서명, 수신자는 공개키로 검증
    - 메시지 위·변조 감지 + 송신자 부인 방지 가능
    - **인증과 무결성 모두 제공**


***3. 로그인, 유저 비밀번호 저장에 사용하는 암호화 방식은 어떤 것이 있을까?***
- **해시 함수 사용** (복호화 불가능한 단방향)
- **bcrypt**: 가장 권장, Salting 자동, 속도 조절 가능 (무차별 대입 공격 방어)
- **scrypt**: 메모리 많이 사용, ASIC 공격 방어
- **Argon2**: 최신 알고리즘, 메모리 하드, 가장 안전
- **PBKDF2**: 많은 반복 연산으로 보안성 향상
- ❌ **SHA-256, MD5 단독 사용 금지**: 너무 빠르고 Rainbow Table 공격에 취약
- **Salt 추가 필수**: 같은 비밀번호도 다른 해시값 생성

### HTTP & HTTPS
***1. HTTPS는 왜 대칭키와 공개키를 동시에 사용할까? 두 방식을 결합하면 각각의 단점을 어떻게 보완할 수 있을까?***
- **공개키 암호화**
    - 서버 인증
    - 세션 키 안전하게 교환 가능
    - 단점: 연산 느림 → 대량 데이터 전송에는 비효율

- **대칭키 암호화**
    - 실제 데이터 전송에 사용 → 빠른 암호화/복호화
    - 단점: 안전하게 키 교환 필요

- **결합 장점**
    - 공개키로 세션 키를 안전하게 교환
    - 교환된 세션 키로 데이터 대칭 암호화 → 빠르고 안전한 통신

***2. CDN이란 무엇이고 어떤 역할을 할까?***
- **CDN(Content Delivery Network)**

    - 전 세계에 분산된 캐시 서버를 통해 사용자 근처에서 콘텐츠 제공
    - 이미지, JS, CSS, 동영상 등 정적 콘텐츠 전송 최적화

- **주요 역할**
    - **속도 향상**: 사용자와 가까운 서버에서 콘텐츠 제공 → 응답 시간 감소
    - **트래픽 분산**: 원본 서버 부하 감소 → 서버 안정성 향상
    - **보안 강화**: DDoS 공격 방어, HTTPS 적용 용이
    - **가용성**: 일부 서버 장애 발생 시 다른 서버가 콘텐츠 제공 → 서비스 중단 최소화
- **예시**: Cloudflare, Akamai, AWS CloudFront
