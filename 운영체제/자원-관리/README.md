# 운영체제 - 자원 관리

## 키워드

**CPU (Central Processing Unit)**

- 연산과 제어 담당
- 프로세스/스레드 실행 관리

**인터럽트 (Interrupt)**

- 프로그램 실행 중 예외 상황 발생 시 CPU에 알리고 처리하는 메커니즘
  - **외부 인터럽트**: 하드웨어 신호 (I/O 완료, 전원 이상 등)
  - **내부 인터럽트**: 예외 상황 (0으로 나누기 등)
  - **소프트웨어 인터럽트**: 시스템 콜 등 명령어에 의한 발생
  - **폴링**: CPU가 상태를 반복 확인 (비효율적)
  - **ISR**: 인터럽트 처리 루틴

**PCB & Context Switching**

- **PCB(Process Control Block)**: 프로세스 정보 저장 (PID, 상태, 레지스터 등)
- **Context Switching**: 실행 중인 프로세스 상태 저장 → 다른 프로세스 상태 복원
  - **Overhead**: 빈번하면 성능 저하
  - 발생 시점: 인터럽트, I/O 대기, 타임 슬라이스 종료 등

**프로세스 간 통신 (IPC)**

- 독립 프로세스 간 데이터 전달 방법
  - **파이프**: 익명(부모-자식) / 네임드(파일 기반, 관계 없음)
  - **메시지 큐**: 메시지 단위 통신
  - **공유 메모리**: 메모리 공간 직접 공유, 속도 빠름
  - **메모리 맵**: 파일을 메모리에 매핑해 공유
  - **소켓**: 네트워크 기반 통신 (로컬/원격)

**CPU 스케줄링**

- CPU 사용을 최적화하기 위한 실행 순서 결정
  - **선점형**: 실행 중에도 CPU 회수 가능 (RR, SRTF 등)
  - **비선점형**: 프로세스가 종료되거나 대기 상태로 전환될 때까지 유지 (FCFS, SJF)
  - **RR (Round Robin)**: 고정 시간 단위로 순환 실행
  - **우선순위 스케줄링**: 우선순위 높은 프로세스 먼저 실행

**데드락 & 경쟁 상태**

- **Deadlock**: 자원 점유 후 서로 기다려서 무한 대기 상태
  - 발생 조건: 상호 배제, 점유 대기, 비선점, 순환 대기
  - 해결: 예방, 회피(Banker 알고리즘), 탐지 및 회복
- **Race Condition**: 다수 프로세스가 동시에 자원 접근하여 결과가 달라지는 상태

**동기화 (Semaphore & Mutex)**

- **임계 구역**: 공유 자원 접근 영역, 동시에 접근 시 충돌 위험
- **세마포어**: 자원 개수만큼 접근 허용 (P: 진입 / V: 종료)
- **뮤텍스**: 하나의 스레드만 접근 가능 (lock/unlock 방식)

**메모리 관리 (페이징 & 세그먼테이션)**

- **페이징(Paging)**: 고정 크기 페이지로 나눠 메모리 할당 (내부 단편화 발생)
- **세그먼테이션(Segmentation)**: 논리 단위(코드/데이터 등)로 나눔 (외부 단편화 발생)
- **가상 메모리**: 필요한 페이지만 메모리에 적재 (스와핑, 페이지 폴트 등 발생)
- **MMU**: 논리 주소 → 물리 주소 변환, 메모리 접근 보호

**페이지 교체 알고리즘**

- 메모리가 가득 찼을 때, 어떤 페이지를 교체할지 결정
  - **FIFO**: 가장 먼저 들어온 페이지 제거
  - **OPT**: 가장 나중에 사용될 페이지 제거 (이론상 최적)
  - **LRU**: 가장 오랫동안 사용되지 않은 페이지 제거
  - **Global vs Local 교체**: 전체 or 프로세스 내에서 교체 범위 결정

**캐시 & 메인 메모리**

- **메인 메모리**: CPU가 직접 접근하는 실행 공간
- **캐시 메모리**: 자주 사용하는 데이터 저장, 속도 향상 (시간·공간 지역성 활용)
- **캐시 라인**: 캐시에 저장되는 데이터 묶음 단위

**파일 시스템**

- 저장 장치의 파일 및 디렉터리를 관리하는 시스템
  - **접근 방식**: 순차 접근, 직접 접근, 색인 접근
  - **디렉터리 구조**: 1단계, 2단계, 트리형, 그래프형
  - **역할**: 파일 관리, 접근 제어, 무결성 유지

## 질문과 답변

## Deadlock & Starvation

### 1. Deadlock 발생 조건 중 가장 제거하기 쉬운 것은?
* **순환 대기(Circular Wait)** 또는 **점유 대기(Hold and Wait)**
   * 순환 대기 제거
      * 자원에 순서(우선순위)를 부여하고 낮은 번호부터 요청하도록 강제
      * 프로토콜 변경만으로 구현 가능하여 시스템 오버헤드가 적음
   * 점유 대기 제거
      * 자원을 요청하기 전에 필요한 모든 자원을 한 번에 확보
      * 이미 점유한 자원을 반납 후 재요청
* 비선점(No Preemption)도 제거 가능
   * 운영체제가 자원을 선점할 수 있도록 설계하기 상대적으로 쉬움
   * 단, 롤백 비용이 발생

### 2. 점유 대기 상태에서 프로세스는 Running인가, Waiting인가?
* **Waiting(또는 Blocked) 상태**
   * 이미 점유한 자원 외에 다른 자원을 기다리기 때문
   * CPU를 점유하지 못하고 자원을 기다리는 상태
   * CPU를 실행(run) 중이 아니므로 Running 상태가 아님

### 3. Deadlock 처리 방법 중 탐지 후 회복 시 자원 선점에서 데이터 일관성 문제는 어떻게 해결하는가?
* **체크포인트(Checkpoint)와 롤백(Rollback)**
   * 프로세스 실행 중 주기적으로 상태를 저장(체크포인트)
   * 자원 선점 시 저장된 체크포인트로 롤백하여 일관성 유지
* **트랜잭션 로그(Transaction Log)**
   * 작업 내역을 순차적으로 기록
   * 롤백 시 로그를 역순으로 실행하여 복구
* **원자성(Atomicity) 보장**
   * 작업을 완전히 완료하거나 전혀 수행하지 않은 상태로 유지

### 4. 기아 상태(Starvation)란 무엇이며, 교착상태(Deadlock)과 어떻게 다른가? 예방 방법은?
* **기아 상태(Starvation)**
   * 특정 프로세스가 자원을 계속 할당받지 못하는 상태
   * 우선순위가 낮아 계속 대기하거나 자원 분배 정책의 불공정성으로 발생
* **Deadlock과의 차이점**
   * Deadlock: 여러 프로세스가 서로의 자원을 기다리며 영원히 대기 (모두 멈춤)
   * Starvation: 일부 프로세스만 계속 기다림 (한 명만 굶음)
   * Deadlock은 자연 해소 불가능, Starvation은 우선순위 변경으로 해소 가능
   * Deadlock은 관련 프로세스 모두 정지, Starvation은 시스템은 계속 실행됨
* **예방 방법**
   * **에이징(Aging) 기법**: 대기 시간이 길어질수록 우선순위를 점진적으로 높임
   * **공정한 스케줄링 정책**: FCFS, Round Robin 등으로 모든 프로세스에 기회 부여
   * **자원 할당 시간 제한**: 특정 자원을 너무 오래 점유하면 선점(회수)
   * **랜덤화(Randomization)**: 확률적으로 다른 프로세스에게도 기회 부여
 
---

## 프로세스 & 스케줄링

### 1. 장기 스케줄러, 중기 스케줄러, 단기 스케줄러의 역할은? 이름이 이렇게 분류된 이유는?
* **장기 스케줄러(Long-term Scheduler)**
   * 역할: 디스크의 프로그램 중 어떤 프로세스를 메모리에 올릴지 결정 (New → Ready)
   * 실행 주기: 느리게, 초 단위 (가끔 실행)
* **중기 스케줄러(Medium-term Scheduler)**
   * 역할: 메모리 부족 시 프로세스를 스왑 아웃/인하여 메모리 부하 조절 (Ready → Suspended)
   * 실행 주기: 중간 정도 (필요 시 실행)
* **단기 스케줄러(Short-term Scheduler)**
   * 역할: Ready Queue의 프로세스 중 CPU에 할당할 프로세스 선택 (Ready → Running)
   * 실행 주기: 아주 자주, 밀리초 단위 (매우 빠름)
* **분류 이유**: 스케줄링이 일어나는 **실행 주기와 속도**에 따라 구분

### 2. 기아 프로세스와 좀비 프로세스 발생 이유 및 해결 방법은?
* **기아 프로세스(Starved Process)**
   * 발생 이유: 우선순위가 낮아 CPU를 계속 할당받지 못함
   * 해결 방법: **에이징(Aging) 기법**으로 대기 시간에 따라 우선순위 상승
* **좀비 프로세스(Zombie Process)**
   * 발생 이유: 자식 프로세스가 종료되었지만 부모 프로세스가 wait() 시스템 콜을 호출하지 않아 PCB가 남아있음
   * 해결 방법
      * 부모가 wait() 시스템 콜로 자식의 종료 상태를 회수
      * 부모가 먼저 종료되면 init 프로세스가 고아 프로세스를 자동으로 회수

### 3. 콘보이 현상(convoy effect)이란 무엇이며, CPU 스케줄러 알고리즘에서 발생하는가?
* **콘보이 현상(Convoy Effect)**
   * 하나의 긴(느린) 프로세스가 CPU를 점유하여 다른 모든 짧은 프로세스들이 줄줄이 기다리는 현상
   * CPU, I/O 자원 전체가 비효율적으로 묶여 평균 대기 시간 증가
* **발생 알고리즘**: **FCFS(First Come First Served)** 비선점형 스케줄러
   * 먼저 도착한 긴 프로세스가 완료될 때까지 다른 프로세스들이 대기
* **해결 방법**: SJF, Round Robin 등의 스케줄링 알고리즘 사용

---

## 동시성 & 동기화

### 1. Race Condition은 언제 발생하며, 어떻게 예방할 수 있는가?
* **발생 시점**
   * 여러 스레드/프로세스가 공유 자원에 동시에 접근할 때
   * 실행 순서에 따라 결과가 달라지는 상황
   * 데이터 불일치 문제 발생
* **예방 방법**
   * **임계 영역(Critical Section) 설정**
   * **Mutex(뮤텍스)**: 한 번에 하나의 스레드만 접근
   * **Semaphore(세마포어)**: 정해진 수만큼의 스레드 접근 허용
   * **Monitor(모니터)**: 고수준 동기화 기법
   * **원자적 연산(Atomic Operation)** 사용

### 2. ISR 중 또 다른 인터럽트 발생 시 처리 방법은?
* **우선순위 기반 처리**
   * 높은 우선순위 인터럽트: 현재 ISR을 중단(선점)하고 먼저 처리
   * 낮은 우선순위 인터럽트: 대기 큐에 저장 후 나중에 처리
* **인터럽트 마스킹(Interrupt Masking)**
   * 중요한 ISR 실행 중 특정 인터럽트를 일시적으로 비활성화
* **중첩된 인터럽트(Nested Interrupt)**
   * ISR 스택이 중첩되어 쌓임
   * 완료된 순서의 역순으로 복귀

---

## 메모리 & 주소 변환

### 1. 물리 주소를 논리 주소로 변환하여 관리하는 장점은?
* **프로세스 독립성과 보호(Protection)**
   * 각 프로세스가 자신만의 독립적인 주소 공간을 가짐
   * 한 프로세스가 다른 프로세스의 메모리에 접근 불가
   * 커널 영역 침범 방지로 보안 강화
* **메모리 관리 유연성(Flexibility)**
   * 프로세스를 메모리 어디든 배치 가능
   * 스왑 인/아웃이 용이
   * 가상 메모리 구현 가능 (실제보다 큰 주소 공간 사용)
* **프로그램 이식성(Portability)**
   * 하드웨어에 독립적인 코드 작성 가능
